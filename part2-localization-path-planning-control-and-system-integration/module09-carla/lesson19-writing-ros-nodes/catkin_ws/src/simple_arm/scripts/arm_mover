#!/usr/bin/env python

import math
import rospy
from std_msgs.msg import Float64
from sensor_msgs.msg import JointState # To use the /simple_arm/joint_states topic to monitor the arm's position
from simple_arm.srv import * # To use the custom service. Generated by Catkin

def at_goal(pos_j1, goal_j1, pos_j2, goal_j2):
    """
    Returns 'true' if the joint positions are close to the goal. Helps for dealing with noise.
    """
    tolerance = .05 # In radians

    result = abs(pos_j1 - goal_j1) <= abs(tolerance)
    result = result and abs(pos_j2 - goal_j2) <= abs(tolerance)

    return result


def clamp_at_boundaries(requested_j1, requested_j2):
    """
    If the requested joint values are outside the allowed boundaries, they are clamped
    to the closest allowed values.
    """
    clamped_j1 = requested_j1
    clamped_j2 = requested_j2

	# Get min and max values from the parameter server
	## The '~' indicates that the parameter is in the private node's namespace
	## The parameter are (e.g.) /simple_arm/min_joint_1_angle
	## The second value is the default value to be returned
    min_j1 = rospy.get_param('~min_joint_1_angle', 0)
    max_j1 = rospy.get_param('~max_joint_1_angle', 2*math.pi)
    min_j2 = rospy.get_param('~min_joint_2_angle', 0)
    max_j2 = rospy.get_param('~max_joint_2_angle', 2*math.pi)

	# Clamp joint angle 1 if necessary
    if not min_j1 <= requested_j1 <= max_j1:
        clamped_j1 = min(max(requested_j1, min_j1), max_j1)
        rospy.logwarn('j1 is out of bounds, valid range (%s,%s), clamping to: %s',
                      min_j1, max_j1, clamped_j1)

	# Clamp joint angle 2 if necessary
    if not min_j2 <= requested_j2 <= max_j2:
        clamped_j2 = min(max(requested_j2, min_j2), max_j2)
        rospy.logwarn('j2 is out of bounds, valid range (%s,%s), clamping to: %s',
                      min_j2, max_j2, clamped_j2)

    return clamped_j1, clamped_j2


def move_arm(pos_j1, pos_j2):
    """
    Commands the arm to move and return the elapsed time during the movement.
    """
    time_elapsed = rospy.Time.now()
    j1_publisher.publish(pos_j1)
    j2_publisher.publish(pos_j2)

	# Monitor the robot's position until it reaches the goal
    while True:
		# Wait until a message from this topic is received
		## WARNING: BLOCKING BEHAVIOR. Not recommended
        joint_state = rospy.wait_for_message('/simple_arm/joint_states', JointState)
		
        if at_goal(joint_state.position[0], pos_j1, joint_state.position[1], pos_j2):
            time_elapsed = joint_state.header.stamp - time_elapsed
            break

    return time_elapsed


def handle_safe_move_request(req):
    """
    Sercie handler function that is called when a client sends a GoToPositionRequest
    to this node.
    
    ::param req:: Position request.
    ::type req:: GoToPositionRequest
    
    ::return:: Position respond.
    ::type return:: GoToPositionRespond
    """
    rospy.loginfo('GoToPositionRequest Received - j1:%s, j2:%s', req.joint_1, req.joint_2)
    clamp_j1, clamp_j2 = clamp_at_boundaries(req.joint_1, req.joint_2)

	# NOTE: Blocking function because wait_for_message() is used inside of it
    time_elapsed = move_arm(clamp_j1, clamp_j2)

    return GoToPositionResponse(time_elapsed)


def mover_service():
    """
    Sets up the node and service
    """
    rospy.init_node('arm_mover')

	# The '~' indicates that 'safe_move' belongs to the private namespace
	## The actual service name will be /simple_arm/safe_move
    service = rospy.Service('~safe_move', GoToPosition, handle_safe_move_request)

	# Iterate until the node receives a shutdown request
	## Without this, the node will disapear after the first request is completed
    rospy.spin()



if __name__ == '__main__':
    j1_publisher = rospy.Publisher('/simple_arm/joint_1_position_controller/command',
                                   Float64, queue_size=10)
    j2_publisher = rospy.Publisher('/simple_arm/joint_2_position_controller/command',
                                   Float64, queue_size=10)

    try:
        mover_service()
    except rospy.ROSInterruptException:
        pass
